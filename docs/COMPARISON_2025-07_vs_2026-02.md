# Snask Comparison: July 2025 (ZIP) vs Feb 18, 2026 (repo)

This document compares two snapshots:

- **July 2025 (ZIP):** `SnaskCode-SnaskInstaller.zip` (folder `SnaskCode-SnaskInstaller/`)
- **Current (Feb 18, 2026):** this repository as of today

## 1) What Snask *was* in July 2025 (ZIP)

### Architecture
- **Interpreter-first**: Snask executed via **Python** (`main.py`) using a **Lark** grammar (`grammar.lark`).
- “Tooling bundle” style: the ZIP also shipped a Windows updater script, a VS Code `.vsix`, and Python runtime artifacts.

### Language surface (as documented in the ZIP README)
The ZIP README describes a playful/DSL-like syntax with keywords such as:
- Variables: `make`, `keep`, `set`, `zap`
- Functions: `craft`, `back`
- Control flow: `when`, `whenn`, `whenem`, `spin`, `loopy`, `breaky`, `skipit`
- Collections: `pack`, `box` (+ helpers like `packadd`, `boxput`, etc.)
- Modules: `to use "module"` (module import)
- Files: `readfile`, `writefile`
- GUI: `window`, `button`, `label`, `entry`, `start_gui_loop` (through a Python bridge)

### Ecosystem + distribution in the ZIP
- A package installer script existed (`snaskpack.py`) that downloaded packages from a local Flask server (“SnaskHub”).
- A Flask-based server bridge existed (`snask_server.py`) to allow Snask to register routes and respond.

## 2) What Snask *is* on Feb 18, 2026 (this repo)

### Architecture
- **Compiled**: Snask is a **Rust compiler** that generates **LLVM IR** and links against a **native C runtime**.
- **Runtime in C**: ships core features and OS/GUI/SQLite/threads primitives (depending on build flags).

### Language surface (current direction)
- More conventional high-level syntax centered around:
  - `class main` + `fun start()`
  - `let/mut/const`, `if/elif/else`, `while`, `for`, etc.
  - module import: `import "lib"` with namespacing (`lib::fn`)
- **Multi-file projects** supported via:
  - `from / import module;`
  - `from dir/subdir import module;`

### Platform tooling
- **SPS (Snask Project System)**:
  - Manifest: `snask.snif` (strict SNIF)
  - Lockfile: `snask.lock`
  - Commands: `snask init/build/run/add/remove/update/list/search/setup/doctor`
- **Distribution**:
  - `snask dist` to generate binaries into `dist/`
  - Linux best-effort: `.deb` / `.AppImage`
  - Linux user install: `snask dist --linux-user` (installs into `~/.local` and writes a `.desktop`)

### GUI
- GUI is now **GTK3-backed** in the runtime (native widgets + CSS support via `gui::css()` and `gui::add_class()`).
- Higher-level GUI ergonomics are built as libraries on top (example: `apps/snask_vault`).

## 3) Biggest differences (high impact)

### A) Interpreter → Compiler (+ native runtime)
**July 2025:** Python interpreter + Lark grammar.

**Feb 2026:** compiled pipeline (LLVM) + C runtime + link step.

Impact:
- Much better performance ceiling.
- “Real” executables.
- More responsibility: ABI, runtime stability, GUI safety, packaging.

### B) “Bundle” tooling → unified ecosystem (SPS + SNIF + lockfile + registry)
**July 2025:** ad-hoc scripts + local “hub”.

**Feb 2026:** a coherent platform workflow:
- `snask.snif` is the single source of truth for projects.
- `snask.lock` improves repeatability.
- `snask doctor` improves supportability.

### C) GUI bridge → native GTK3 runtime
**July 2025:** Python/Tkinter bridge style.

**Feb 2026:** GTK3 in runtime + library wrappers + CSS styling.

## 4) “Old vs new” mapping (conceptual)

This is not a 1:1 compatibility mapping (syntax changed), but conceptually:

- `to use "X"` → `import "X"` (and now also `from ... import X;`)
- `window/button/label/entry/start_gui_loop` → `gui::window/gui::button/.../gui::run`
- `readfile/writefile` → `sfs::read/sfs::write` (and OS/path helpers via `os::...`)

## 5) Regressions / what the ZIP had that the new system doesn’t replicate 1:1

- The ZIP “fun” syntax is not source-compatible with the current compiler syntax.
- The ZIP shipped a ready-made Flask bridge (`snask_server.py`) that made web routing easy to prototype.
  - Current Snask can do web (Blaze existed in earlier work), but the ZIP’s integration approach is different.
- The ZIP’s packaging story was “ship the whole bundle”.
  - The current direction is “ship compiler + runtime + packages + dist”.

## 6) Why the Feb 2026 direction is stronger (platform language goal)

The current repo aligns with:
> “Snask is a batteries-included platform language for building fast desktop and tooling applications with a unified ecosystem.”

Because it provides:
- A stable build pipeline (compiler + runtime)
- A project system (SPS)
- A standard config/interchange format (SNIF)
- A packaging/distribution story (`snask dist`)
- A GUI story (GTK3 runtime + libraries)

## 7) Recommended next steps (to keep momentum)

- **Stability**: lock down runtime + core syntax changes (minimize breaking changes).
- **DX**: continue improving diagnostics and “golden path” project templates.
- **Packaging**: expand `snask dist` metadata support (icons, desktop entries, versioning, license).
- **Security**: treat credential storage as “real security work” (encryption + OS keyring) if Vault becomes more than a demo.

