import "json";
import "os";

// Biblioteca: blaze
// Micro-framework estilo Flask/Django (minimalista).
//
// Modelo:
// - Você monta um objeto `routes` (SNASK_OBJ) com chaves:
//     "/path"              (qualquer método)
//     "GET /path"          (rota por método)
//     "POST /path"
// - Valores podem ser:
//     - string: responde text/plain
//     - qualquer valor/objeto: responde application/json (stringify)
//     - response object (objeto com campos):
//         { "body": "texto", "status": 200, "content_type": "text/plain; charset=utf-8" }
//         { "json": <qualquer>, "status": 200 }
//         { "redirect": "https://...", "status": 302 }

// ---------- Core ----------
fun new()
    return json::new_object();

fun run(port, routes)
    return blaze_run(port, routes);

fun route(routes, path, value)
    return json::set(routes, path, value);

fun route_method(routes, method, path, value)
    return json::set(routes, method + " " + path, value);

fun get(routes, path, value)
    return blaze::route_method(routes, "GET", path, value);

fun post(routes, path, value)
    return blaze::route_method(routes, "POST", path, value);

fun put(routes, path, value)
    return blaze::route_method(routes, "PUT", path, value);

fun patch(routes, path, value)
    return blaze::route_method(routes, "PATCH", path, value);

fun delete(routes, path, value)
    return blaze::route_method(routes, "DELETE", path, value);

// ---------- Response builders ----------
fun resp_text(body)
    let r = json::new_object();
    json::set(r, "body", body);
    json::set(r, "status", 200);
    json::set(r, "content_type", "text/plain; charset=utf-8");
    return r;

fun resp_html(body)
    let r = json::new_object();
    json::set(r, "body", body);
    json::set(r, "status", 200);
    json::set(r, "content_type", "text/html; charset=utf-8");
    return r;

fun resp_json(value)
    let r = json::new_object();
    json::set(r, "json", value);
    json::set(r, "status", 200);
    json::set(r, "content_type", "application/json; charset=utf-8");
    return r;

fun resp_status(status)
    let r = json::new_object();
    json::set(r, "status", status);
    json::set(r, "body", "");
    json::set(r, "content_type", "text/plain; charset=utf-8");
    return r;

fun resp(status, content_type, body)
    let r = json::new_object();
    json::set(r, "status", status);
    json::set(r, "content_type", content_type);
    json::set(r, "body", body);
    return r;

fun json_resp(status, value)
    let r = json::new_object();
    json::set(r, "status", status);
    json::set(r, "content_type", "application/json; charset=utf-8");
    json::set(r, "json", value);
    return r;

fun redirect(url)
    let r = json::new_object();
    json::set(r, "status", 302);
    json::set(r, "redirect", url);
    return r;

fun ok()
    return blaze::resp_text("ok");

fun not_found()
    return blaze::resp(404, "text/plain; charset=utf-8", "Not Found");

fun bad_request()
    return blaze::resp(400, "text/plain; charset=utf-8", "Bad Request");

fun internal_error()
    return blaze::resp(500, "text/plain; charset=utf-8", "Internal Server Error");

// ---------- Static helpers ----------
fun file_text(path)
    return blaze::resp_text(os::read_file(path));

fun file_html(path)
    return blaze::resp_html(os::read_file(path));

fun file_json(path)
    return blaze::resp_json(os::read_json(path));

fun route_file_text(routes, path, file_path)
    return blaze::route(routes, path, blaze::file_text(file_path));

fun route_file_html(routes, path, file_path)
    return blaze::route(routes, path, blaze::file_html(file_path));

fun route_file_json(routes, path, file_path)
    return blaze::route(routes, path, blaze::file_json(file_path));

// ---------- Convenience / meta ----------
fun version()
    return "0.2.0";

fun routes_to_json(routes)
    return json::stringify(routes);

fun routes_count(routes)
    return json::len(routes);

fun has_route(routes, path)
    return json::has(routes, path);

fun remove_route(routes, path)
    // Sem runtime para remover chave; retorna false por enquanto.
    return false;

fun route_text(routes, path, text)
    return blaze::route(routes, path, blaze::resp_text(text));

// ---------- Handlers (dinâmico) ----------
// Registra um handler Snask por nome. O handler deve existir como função top-level:
//     fun my_handler(method, path, query, body, cookie)
// e retornar:
//     - string, ou
//     - response-object (body/json/status/content_type/header/cookie), ou
//     - qualquer valor (vira JSON)
fun handler(routes, path, handler_name)
    let o = json::new_object();
    json::set(o, "handler", handler_name);
    return blaze::route(routes, path, o);

fun handler_method(routes, method, path, handler_name)
    let o = json::new_object();
    json::set(o, "handler", handler_name);
    return blaze::route_method(routes, method, path, o);

fun handler_get(routes, path, handler_name)
    return blaze::handler_method(routes, "GET", path, handler_name);

fun handler_post(routes, path, handler_name)
    return blaze::handler_method(routes, "POST", path, handler_name);

fun handler_put(routes, path, handler_name)
    return blaze::handler_method(routes, "PUT", path, handler_name);

fun handler_patch(routes, path, handler_name)
    return blaze::handler_method(routes, "PATCH", path, handler_name);

fun handler_delete(routes, path, handler_name)
    return blaze::handler_method(routes, "DELETE", path, handler_name);

// Helpers de parsing do request (para uso dentro de handlers)
fun qs_get(query, key)
    return blaze_qs_get(query, key);

fun cookie_get(cookie_header, name)
    return blaze_cookie_get(cookie_header, name);
